---
# Preamble

## Author
author:
  name: Артём Дмитриевич Петлин
  degrees: Student
  orcid: 0000-0002-0877-7063
  email: 1132246846@pfur.ru
  affiliation:
    - name: Российский университет дружбы народов
      country: Российская Федерация
      postal-code: 117198
      city: Москва
      address: ул. Миклухо-Маклая, д. 6
## Title
title: "Отчёт по третьему разделу внешнего курса"
license: "CC BY"
## Generic options
lang: ru-RU
number-sections: true
toc: true
toc-title: "Содержание"
toc-depth: 2
## Crossref customization
crossref:
  lof-title: "Список иллюстраций"
  lot-title: "Список таблиц"
  lol-title: "Листинги"
## Bibliography
bibliography:
  - bib/cite.bib
csl: _resources/csl/gost-r-7-0-5-2008-numeric.csl
## Formats
format:
### Pdf output format
  pdf:
    toc: true
    number-sections: true
    colorlinks: false
    toc-depth: 2
    lof: true # List of figures
    lot: true # List of tables
#### Document
    documentclass: scrreprt
    papersize: a4
    fontsize: 12pt
    linestretch: 1.5
#### Language
    babel-lang: russian
    babel-otherlangs: english
#### Biblatex
    cite-method: biblatex
    biblio-style: gost-numeric
    biblatexoptions:
      - backend=biber
      - langhook=extras
      - autolang=other*
#### Misc options
    csquotes: true
    indent: true
    header-includes: |
      \usepackage{indentfirst}
      \usepackage{float}
      \floatplacement{figure}{H}
      \usepackage[math,RM={Scale=0.94},SS={Scale=0.94},SScon={Scale=0.94},TT={Scale=MatchLowercase,FakeStretch=0.9},DefaultFeatures={Ligatures=Common}]{plex-otf}
### Docx output format
  docx:
    toc: true
    number-sections: true
    toc-depth: 2
---

# Цель работы

Выполнить третий раздел внешнего курса "Системный администратор Linux с нуля".

# Задание

Задания восьмого, девятого, десятого и одиннадццатого модулей, а также тесты.

# Теоретическое введение

- Модуль 8. Настройка сети и SSH
- Модуль 9: Управление пакетами
- Модуль 10: Управление логами
- Модуль 10: Управление логами

# Выполнение практических заданий

![модуль 8](image/1.jpg){#fig-001 width=100%}

Настраиваем статический IP на тестовом сервере вручную.

![модуль 8](image/2.jpg){#fig-002 width=100%}

В файле /etc/network/interfaces прописываем конфигурацию для интерфейса eth0.

![модуль 8](image/3.jpg){#fig-003 width=100%}

Проверяем доступность внешних ресурсов через ping.

![модуль 8](image/4.jpg){#fig-004 width=100%}

Удаляем текущий IP-адрес с интерфейса. Запускаем любой веб-сервер на 80 порту (например, nginx) и проверяем, что он работает. 

![модуль 8](image/5.jpg){#fig-005 width=100%}

С помощью утилиты dig узнаем IP-адреса популярных сервисов.

![модуль 8](image/6.jpg){#fig-006 width=100%}

Проверяем, слушает ли SSH-порт на сервере.

![модуль 8](image/7.jpg){#fig-007 width=100%}

Изменяем порт SSH и запрещаем вход по паролю.

![модуль 8](image/11.jpg){#fig-011 width=100%}

Настраиваем подключение по ключу и авторизуемся.

![модуль 8](image/12.jpg){#fig-012 width=100%}

Разрешаем SSH-доступ только для определенных пользователей. Убеждаемся, что для другого пользователя подключение не сработает.

![модуль 8](image/13.jpg){#fig-013 width=100%}

Настраиваем UFW для ограничения доступа только для SSH.

![модуль 8](image/14.jpg){#fig-014 width=100%}

Настраиваем UFW, чтобы доступ по SSH был только из вашей локальной сети.

![модуль 8](image/15.jpg){#fig-015 width=100%}

![модуль 8](image/16.jpg){#fig-016 width=100%}

Используя fail2ban, создаем jail, который будет блокировать IP-адрес после трех успешных запросов к nginx.

![модуль 8](image/17.jpg){#fig-017 width=100%}

Проверяем, как работает блокировка при множественных запросах.

![модуль 9](image/18.jpg){#fig-018 width=100%}

Находим и устанавливаем утилиту htop.

![модуль 9](image/19.jpg){#fig-019 width=100%}

Удаляем утилиту htop, затем устанавливаем заново с полной очисткой (purge).

![модуль 9](image/20.jpg){#fig-020 width=100%}

Выполняем полное обновление системы.

![модуль 9](image/22.jpg){#fig-022 width=100%}

Настраиваем автоматическую установку обновлений безопасности.

![модуль 9](image/23.jpg){#fig-023 width=100%}

  Удаляем устаревшие и неиспользуемые зависимости.

![модуль 9](image/24.jpg){#fig-024 width=100%}

Устанавливаем пакет вручную через dpkg, предварительно скачав его с сайта.

![модуль 9](image/25.jpg){#fig-025 width=100%}

Анализируем, какие зависимости потребуются.

![модуль 10](image/26.jpg){#fig-026 width=100%}

![модуль 10](image/27.jpg){#fig-027 width=100%}

Просматриваем содержимое основного системного журнала и журнала аутентификации, используя утилиту для постраничного просмотра.

![модуль 10](image/28.jpg){#fig-028 width=100%}

Выводим последние 20 записей из бинарного системного журнала с помощью journalctl.

![модуль 10](image/29.jpg){#fig-029 width=100%}

Проверяем наличие и расположение файла журнала ошибок веб-сервера Nginx.

![модуль 10](image/30.jpg){#fig-030 width=100%}

Изучаем любую одну строку из файла /var/log/auth.log и вручную определяем в ней: временную метку, имя сервиса (процесса) и описание события.

![модуль 10](image/31.jpg){#fig-031 width=100%}

Проверяем текущий статус служб rsyslog и systemd-journald с помощью systemctl.

![модуль 10](image/32.jpg){#fig-032 width=100%}

![модуль 10](image/33.jpg){#fig-033 width=100%}

Генерируем тестовое сообщение с помощью утилиты logger. Затем находим это сообщение сначала в выводе journalctl, а потом в файле /var/log/syslog. Используя journalctl, фильтруем и выводим только те события, которые имеют уровень важности error (err) или более критичный. Заглядываем в конфигурационный файл rsyslog (например, /etc/rsyslog.d/50-default.conf) и находим строку, отвечающую за направление сообщений от категорий (facility) auth и authpriv в файл /var/log/auth.log. Отправляем в системный журнал сообщение с явно указанным уровнем важности warning. Убеждаемся, что оно появляется в выводе journalctl при фильтрации по этому уровню.

![модуль 10](image/34.jpg){#fig-034 width=100%}

Находим все строки в файле /var/log/auth.log, в которых упоминается неудачная попытка входа по паролю (Failed password), не обращая внимания на регистр символов. Строим конвейер команд, который сначала найдет все успешные SSH-подключения (Accepted password) в /var/log/auth.log, а затем извлечет из этих строк только IP-адреса подключившихся клиентов. Составляем список уникальных IP-адресов, с которых были зафиксированы неудачные попытки входа в систему. Собираем статистику и выведите пять IP-адресов, с которых было зафиксировано наибольшее количество успешных входов по SSH.

![модуль 10](image/35.jpg){#fig-035 width=100%}

Используя journalctl, отображаем все системные журналы за последние 15 минут.

![модуль 10](image/36.jpg){#fig-036 width=100%}

Находим в журнале аутентификации /var/log/auth.log все попытки входа от имени несуществующих пользователей.

![модуль 10](image/37.jpg){#fig-037 width=100%}

Определяем IP-адрес, с которого было совершено наибольшее количество неудачных попыток подбора пароля (Failed password). После определения наиболее подозрительного IP-адреса из предыдущего шага, извлекаем из /var/log/auth.log абсолютно все записи, связанные с этим IP, и сохраняем их в отдельный файл incident_report.log. Рассчитываем контрольную сумму SHA256 для созданного файла incident_report.log, чтобы зафиксировать его целостность и доказать, что он не изменялся после сбора. Проверяем, какие команды выполнялись с правами суперпользователя (через sudo) вашим текущим пользователем.

![модуль 10](image/38.jpg){#fig-038 width=100%}

Изучаем существующую конфигурацию logrotate для системного менеджера пакетов (apt или dpkg) в директории /etc/logrotate.d/. Определяем, как часто происходит ротация, сколько архивных копий хранится и используется ли сжатие.

![модуль 10](image/39.jpg){#fig-039 width=100%}

Создаем собственный конфигурационный файл /etc/logrotate.d/testapp для управления вымышленным лог-файлом /var/log/testapp.log. Настраиваем его на ежедневную ротацию, хранение четырех архивных копий и сжатие старых логов.

![модуль 10](image/40.jpg){#fig-040 width=100%}

Проверяем созданную конфигурацию logrotate на синтаксические ошибки, выполнив «сухой запуск» в режиме отладки.

![модуль 10](image/41.jpg){#fig-041 width=100%}

Принудительно запускаем ротацию для лога testapp и проверьте результат: убеждаемся, что старый лог был сжат и переименован, а на его месте появился новый пустой файл. Пишем строку конфигурации для rsyslog, которая будет пересылать абсолютно все логи (*.*) по протоколу TCP на удаленный сервер с адресом logs.example.com и стандартным портом 514.

![модуль 11](image/42.jpg){#fig-042 width=100%}

Устанавливаем Podman и проверяем установку.

![модуль 11](image/43.jpg){#fig-043 width=100%}

![модуль 11](image/44.jpg){#fig-044 width=100%}

Запускаем контейнер.

![модуль 11](image/45.jpg){#fig-045 width=100%}

Запускаем Nginx и проверяем, что он работает.

![модуль 11](image/46.jpg){#fig-046 width=100%}

Разворачиваем сайт в Nginx, используя локальную папку с HTML-файлами.

![модуль 11](image/47.jpg){#fig-047 width=100%}

Запускаем контейнер Nginx с ограничением памяти в 100 МБ и проверяем его работу.

![модуль 11](image/48.jpg){#fig-048 width=100%}

![модуль 11](image/49.jpg){#fig-049 width=100%}

![модуль 11](image/50.jpg){#fig-050 width=100%}

Исследуем поведение контейнера при исчерпании выделенной памяти.

![модуль 11](image/51.jpg){#fig-051 width=100%}

![модуль 11](image/52.jpg){#fig-052 width=100%}

![модуль 11](image/53.jpg){#fig-053 width=100%}

![модуль 11](image/54.jpg){#fig-054 width=100%}

Создаем и запускаем кастомный веб-сайт на базе nginx с использованием Podman.

![модуль 11](image/55.jpg){#fig-055 width=100%}

Сохраняем образ и переносим его на другой сервер.


# Выполнение тестовых заданий

![тест](image/1a.jpg){#fig-001 width=100%}

Мы используем команду ip a add для временного добавления IP-адреса к сетевому интерфейсу.
Директива auto в файле /etc/network/interfaces указывает системе, какие интерфейсы нужно автоматически активировать (поднимать) во время загрузки.
Для удаления конкретного IP-адреса с интерфейса мы используем команду ip a del с указанием полного адреса с маской и имени интерфейса.

![тест](image/2a.jpg){#fig-002 width=100%}

Настройки, заданные с помощью команды ip, являются временными и действуют только до перезагрузки системы.
При статической настройке сети в файле /etc/network/interfaces мы указываем шлюз по умолчанию с помощью директивы gateway в блоке настроек интерфейса.

![тест](image/3a.jpg){#fig-003 width=100%}

Мы используем современную утилиту ss с ключами -t , -u , -l, -n, -p для получения полного списка открытых портов и связанных с ними процессов.
Ключ -p в команде ss заставляет ее отображать идентификатор процесса (PID) и его имя, которое использует данный сокет.

![тест](image/4a.jpg){#fig-004 width=100%}

Мы используем команду dig для выполнения DNS-запросов и получения подробной информации о доменных именах, включая их IP-адреса.
Для быстрой проверки доступности удаленного TCP-порта мы используем утилиту netcat с ключами -v и -z.

![тест](image/5a.jpg){#fig-005 width=100%}

По умолчанию демон SSH-сервера прослушивает входящие подключения на TCP-порту 22.
Главный файл конфигурации для серверной части SSH находится по пути /etc/ssh/sshd_config. Файл ssh_config предназначен для клиентской части.
Для временной остановки системного сервиса мы используем команду systemctl stop. 

![тест](image/6a.jpg){#fig-006 width=100%}

Для настройки аутентификации по SSH-ключу мы копируем содержимое файла публичного ключа в файл authorized_keys на сервере.
Директива PermitRootLogin no в файле /etc/ssh/sshd_config запрещает прямое подключение к серверу по SSH под учетной записью root, что является важной мерой безопасности.

![тест](image/7a.jpg){#fig-007 width=100%}

После настройки правил мы активируем межсетевой экран UFW командой ufw enable. Это применяет правила и включает автозагрузку файрвола при старте системы.
Основные настройки jails Fail2ban, которые определяют правила блокировки, хранятся в файле /etc/fail2ban/jail.conf.
Чтобы удалить правило по его номеру из списка, выведенного командой ufw status numbered, мы используем команду ufw delete [номер].

![тест](image/8a.jpg){#fig-008 width=100%}

Параметр bantime в конфигурации jail Fail2ban определяет длительность блокировки IP-адреса в секундах после превышения лимита попыток.
Для ограничения доступа к порту по источнику мы используем синтаксис ufw allow from [источник] to any port [порт]. Это разрешает подключения только с указанной подсети.

![тест](image/9a.jpg){#fig-009 width=100%}

Команда apt autoremove удаляет пакеты, которые были установлены автоматически как зависимости и больше не нужны. Сами целевые пакеты удаляются командой remove, а их конфиги остаются.
Команда apt purge удаляет пакет вместе с его конфигурационными файлами. Зависимости, установленные с ним, при этом остаются в системе.
Мы регулярно выполняем apt update, чтобы обновить локальную базу данных пакетов. Без этого система не будет знать о новых версиях пакетов.

![тест](image/10a.jpg){#fig-010 width=100%}

Пакет unattended-upgrades позволяет нам настроить автоматическую установку обновлений безопасности и других пакетов без ручного вмешательства.
После apt update мы выполняем apt upgrade, чтобы установить все доступные обновления для установленных пакетов.
Команда apt full-upgrade выполняет более интеллектуальное обновление, которое может удалять obsolete пакеты или устанавливать новые зависимости, что иногда необходимо для полного обновления системы.

![тест](image/11a.jpg){#fig-011 width=100%}

При возникновении проблем с зависимостями мы используем команду apt --fix-broken install, чтобы попытаться автоматически исправить нарушенные зависимости.
Принудительное удаление пакета, от которого зависят другие программы, приводит к "разрыву зависимостей".
Для фильтрации вывода других команд и поиска конкретного пакета мы используем конвейер с grep.

![тест](image/12a.jpg){#fig-012 width=100%}

Мы предпочитаем устанавливать .deb файлы через apt, так как он автоматически разрешает и устанавливает все зависимости.
APT проверяет целостность и подлинность пакетов из репозиториев с помощью GPG-ключей, что защищает систему от установки модифицированных или вредоносных пакетов.
В корпоративной среде, если нужного пакета нет в утвержденных репозиториях, правильным действием является запрос на его добавление через систему тикетов, а не самостоятельная установка из непроверенных источников.

![тест](image/13a.jpg){#fig-013 width=100%}

Мы используем логи в первую очередь для этих трех целей: найти причину неисправности, выяснить обстоятельства взлома и определить "узкие места" в системе.
Ошибка 502 обычно указывает на проблему связи веб-сервера с backend-процессом.
В современных системах логи хранятся в двух основных местах: классические текстовые файлы в /var/log/ и централизованный бинарный журнал systemd, который мы просматриваем с помощью journalctl.

![тест](image/14a.jpg){#fig-014 width=100%}

Обычно systemd-journald действует как первичный сборщик логов, а затем, при наличии настроек, перенаправляет сообщения в демон syslog для постоянного хранения в привычных текстовых файлах в /var/log/.
Сбой запуска критичной системной службы — это значимое негативное событие, которое классифицируется уровнем error, а не просто информационным сообщением.
Категория в syslog указывает на подсистему или программу-источник сообщения.

![тест](image/15a.jpg){#fig-015 width=100%}

Чтобы uniq мог корректно подсчитать повторяющиеся строки, они должны следовать друг за другом.
В awk $1, $2, $3 и т.д. обозначают первое, второе, третье и последующие поля в строке.
Мы используем конвейер: первый grep отфильтровывает строки с "error", а второй grep с ключом -v удаляет из этого результата строки, содержащие "healthcheck".

![тест](image/16a.jpg){#fig-016 width=100%}

Большое количество неудачных попыток входа за короткий промежуток времени, особенно для стандартных имен пользователей, является классическим признаком автоматизированной brute-force атаки.
Расчет хеша фиксирует текущее состояние файла.
Команды, выполненные через sudo, подробно логируются в журналах аутентификации.

![тест](image/17a.jpg){#fig-017 width=100%}

Основная задача logrotate — ротация, архивация и удаление старых лог-файлов по заданному расписанию и правилам.
Удаленный сбор логов обеспечивает целостность журналов.
Grafana Loki спроектирован именно для этого сценария.

![тест](image/18a.jpg){#fig-018 width=100%}

Команда podman info выводит подробную информацию о среде Podman: версию, конфигурацию, хранилища, сеть и т.д., что помогает нам проверить корректность его настройки.
Ключевое архитектурное отличие Podman в том, что он использует архитектуру без демона.
Ключ --rm автоматически удаляет контейнер сразу после того, как он завершит свою работу.

![тест](image/19a.jpg){#fig-019 width=100%}

Безопасность Podman для многопользовательских сред обусловлена его способностью работать в rootless-режиме.
Как уже было отмечено, Podman не требует постоянно работающего фонового демона.

![тест](image/20a.jpg){#fig-020 width=100%}

Мы используем команду podman run для запуска нового контейнера.
Флаг -v используется для монтирования директорий или файлов с хостовой машины внутрь контейнера.
Комбинация флагов -i и -t позволяет нам запустить контейнер в интерактивном режиме с псевдо-TTY.

![тест](image/21a.jpg){#fig-021 width=100%}

По умолчанию podman ps показывает только работающие контейнеры. Чтобы увидеть все контейнеры, включая остановленные, мы добавляем флаг -a.
Флаг --rm заставляет Podman автоматически удалять контейнер сразу после его остановки.

![тест](image/22a.jpg){#fig-022 width=100%}

Для мониторинга потребления ресурсов работающими контейнерами в реальном времени мы используем команду podman stats.
Флаг -d запускает контейнер в фоновом режиме. После запуска управление возвращается в терминал, а контейнер продолжает работать независимо.
После изменения unit-файлов systemd мы выполняем systemctl daemon-reload.

![тест](image/23a.jpg){#fig-023 width=100%}

Когда контейнер запущен как systemd-сервис, его логи интегрируются в общий журнал systemd.
Флаг --memory устанавливает максимальный лимит оперативной памяти, который может использовать контейнер.

![тест](image/24a.jpg){#fig-024 width=100%}

Для загрузки Docker-образов из удаленного реестра мы используем команду podman pull.
Файл policy.json определяет политику доверия для образов контейнеров. В нем мы настраиваем, из каких реестров разрешено скачивать образы, требуется ли для них цифровая подпись и какие ключи являются доверенными.
Команда podman build используется для сборки собственного образа контейнера.


![тест](image/25a.jpg){#fig-025 width=100%}

Мы используем podman build -t myapp . для создания собственного образа из инструкций в Dockerfile, который находится в текущей директории. Результатом будет образ с именем myapp.
Если в политике доверия (policy.json) для определенного реестра или образа указана директива signedBy, то Podman будет проверять наличие и валидность цифровой подписи у образа.

# Оценки тестов

![тест 1](image/test1.jpg){#fig-001 width=100%}

![тест 2](image/test2.jpg){#fig-002 width=100%}

![тест 3](image/test3.jpg){#fig-003 width=100%}

![тест 4](image/test4.jpg){#fig-004 width=100%}

![тест 5](image/test5.jpg){#fig-005 width=100%}

![тест 6](image/test6.jpg){#fig-006 width=100%}

![тест 7](image/test7.jpg){#fig-007 width=100%}

![тест 8](image/test8.jpg){#fig-008 width=100%}

![тест 9](image/test9.jpg){#fig-009 width=100%}

![тест 10](image/test10.jpg){#fig-010 width=100%}

![тест 11](image/test11.jpg){#fig-011 width=100%}

![тест 12](image/test12.jpg){#fig-012 width=100%}

![тест 13](image/test13.jpg){#fig-013 width=100%}

![тест 14](image/test14.jpg){#fig-014 width=100%}

![тест 15](image/test15.jpg){#fig-015 width=100%}

![тест 16](image/test16.jpg){#fig-016 width=100%}

![тест 17](image/test17.jpg){#fig-017 width=100%}

# Выводы

Мы выполнили третий раздел внешнего курса "Системный администратор Linux с нуля".

# Список литературы{.unnumbered}

::: {.refs}
1. https://study.selectel.ru/members/courses/course756726784647
:::
