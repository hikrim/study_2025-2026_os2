---
# Preamble

## Author
author:
  name: Артём Дмитриевич Петлин
  degrees: Student
  orcid: 0000-0002-0877-7063
  email: 1132246846@pfur.ru
  affiliation:
    - name: Российский университет дружбы народов
      country: Российская Федерация
      postal-code: 117198
      city: Москва
      address: ул. Миклухо-Маклая, д. 6
## Title
title: "Отчёт по второму разделу внешнего курса"
license: "CC BY"
## Generic options
lang: ru-RU
number-sections: true
toc: true
toc-title: "Содержание"
toc-depth: 2
## Crossref customization
crossref:
  lof-title: "Список иллюстраций"
  lot-title: "Список таблиц"
  lol-title: "Листинги"
## Bibliography
bibliography:
  - bib/cite.bib
csl: _resources/csl/gost-r-7-0-5-2008-numeric.csl
## Formats
format:
### Pdf output format
  pdf:
    toc: true
    number-sections: true
    colorlinks: false
    toc-depth: 2
    lof: true # List of figures
    lot: true # List of tables
#### Document
    documentclass: scrreprt
    papersize: a4
    fontsize: 12pt
    linestretch: 1.5
#### Language
    babel-lang: russian
    babel-otherlangs: english
#### Biblatex
    cite-method: biblatex
    biblio-style: gost-numeric
    biblatexoptions:
      - backend=biber
      - langhook=extras
      - autolang=other*
#### Misc options
    csquotes: true
    indent: true
    header-includes: |
      \usepackage{indentfirst}
      \usepackage{float}
      \floatplacement{figure}{H}
      \usepackage[math,RM={Scale=0.94},SS={Scale=0.94},SScon={Scale=0.94},TT={Scale=MatchLowercase,FakeStretch=0.9},DefaultFeatures={Ligatures=Common}]{plex-otf}
### Docx output format
  docx:
    toc: true
    number-sections: true
    toc-depth: 2
---

# Цель работы

Выполнить второй раздел внешнего курса "Системный администратор Linux с нуля".

# Задание

Задания четвертого, пятого, шестого и седьмого модулей, а также тесты.

# Теоретическое введение

- Модуль 4. Получение справки. Использование справочных систем, работа с текстовыми файлами и логами
- Модуль 5. Управление пользователями и группами
- Модуль 6. Управление доступом
- Модуль 7. Управление процессами

# Выполнение практических заданий

![модуль 4](image/1.jpg){#fig-001 width=100%}

Используес man чтобы узнать, как работает команда grep.

![модуль 4](image/2.jpg){#fig-002 width=100%}

Находим документацию о systemctl с помощью info.

![модуль 4](image/3.jpg){#fig-003 width=100%}

Откройте локальную документацию о info.

![модуль 4](image/4.jpg){#fig-004 width=100%}

Открываем файл /etc/os-release с помощью less и находим название дистрибутива.

![модуль 4](image/5.jpg){#fig-005 width=100%}

Исопльзуем grep, чтобы найти строки, содержащие «error» в файле /var/log/syslog.

![модуль 4](image/6.jpg){#fig-006 width=100%}

Отредактируем конфигурацию SSH с помощью nano или vim и изменяем параметр PermitRootLogin no.

![модуль 4](image/7.jpg){#fig-007 width=100%}

Создаем небольшой файл с матрицей чисел произвольного размера, и поэкспериментируем с числами при помощи утилиты awk — например, посчитаем сумму чисел в каждой четной строке.

![модуль 4](image/8.jpg){#fig-008 width=100%}

Находим все ошибки в системном журнале за последний день.

![модуль 4](image/9.jpg){#fig-009 width=100%}

Проверяем логи SSH и находим неудачные попытки входа.

![модуль 4](image/10.jpg){#fig-010 width=100%}

Пишем скрипт, который ежедневно сохраняет в файл все ошибки из /var/log/syslog.

![модуль 4](image/11.jpg){#fig-011 width=100%}

Натстраиваем cron, чтобы скрипт выполнялся раз в день.

![модуль 4](image/12.jpg){#fig-012 width=100%}

Используем grep, чтобы посчитать количество неудачных попыток входа за последние 24 часа.

![модуль 5](image/13.jpg){#fig-013 width=100%}

Создаем нового пользователя ivan и задаем ему пароль.

![модуль 5](image/14.jpg){#fig-014 width=100%}

Создаем новую группу developers. Добавляем пользователя ivan в группу developers. Создаем группу testers и меняем принадлежность пользователя ivan группам c developers на testers. Удаляем учетную запись пользователя ivan вместе с его домашним каталогом.

![модуль 5](image/15.jpg){#fig-015 width=100%}

Создаем где‑нибудь новый файл. Изучаем разрешения, которые он получил автоматически. Имеют именно такие значения из-за umask.

![модуль 5](image/16.jpg){#fig-016 width=100%}

Для созданного файла убераем права на запись для группы и на чтение для всех остальных. Возвращаем первоначальные доступы файлу, используя числовую форму.

![модуль 5](image/17.jpg){#fig-017 width=100%}

Делаем владельцем файла пользователя root. 

![модуль 5](image/18.jpg){#fig-018 width=100%}

Возвращаем себе владение файлом.

![модуль 5](image/19.jpg){#fig-019 width=100%}

Выполняем несколько действий, используя sudo, и находим их в системном журнале.

![модуль 5](image/20.jpg){#fig-020 width=100%}

Пользуемся учетной записью ivan из предыдущих уроков. Проверяем, может ли он выполнять команды суперпользователя. Если нет, предоставляем ему такую возможность.

![модуль 5](image/21.jpg){#fig-021 width=100%}

Выводим имена всех пользователей, у которых в качестве алгоритма хеширования пароля указан устаревший SHA-512 (его префикс $6$).

![модуль 5](image/22.jpg){#fig-022 width=100%}

Создаем пользователя ivan. Устанавливаем для него нужные параметры политики паролей с помощью команды chage. Блокируем вход пользователю ivan. 

![модуль 5](image/23.jpg){#fig-023 width=100%}

Убеждаемся, что он не может войти в систему.

![модуль 5](image/24.jpg){#fig-024 width=100%}

Возрвращаем пользователю ivan возможность авторизоваться.

![модуль 6](image/25.jpg){#fig-025 width=100%}

Проверяем права доступа к /etc/passwd, /home и /var/log.

![модуль 6](image/26.jpg){#fig-026 width=100%}

Создаем файл в домашнем каталоге, проверяем его права и настройте umask, чтобы у новых файлов не было прав для категории остальных пользователей.
 
![модуль 6](image/27.jpg){#fig-027 width=100%}

Создаем файл и настройте ему права 644, чтобы владелец мог редактировать, а остальные — только читать. Создаем группу admins, меняем группу у созданного файла в первом задании на эту и передаем группе право на изменение (запись).

![модуль 6](image/28.jpg){#fig-028 width=100%}

Разрешаем конкретному пользователю изменять файл, не добавляя его в основную группу владельца. Утсанавливаем особые права для группы, чтобы она могла только выполнять файл. Проверяем и сбрасываем все ACL с файла.

![модуль 6](image/29.jpg){#fig-029 width=100%}

Устанавливаем SUID на исполняемый файл, чтобы он запускался от имени владельца. Настраиваем SGID для каталога, чтобы новые файлы наследовали группу. Делаем так, чтобы категория других пользователей могли записывать в /public_folder, но не могли удалять чужие файлы.

![модуль 7](image/30.jpg){#fig-030 width=100%}

Находим процесс, потребляющий больше всего памяти и завершаем его.

![модуль 7](image/31.jpg){#fig-031 width=100%}

Запускаем процесс в фоновом режиме, возвращаем его на передний план, приостанавливаем процесс, затем возвращаем в фон.

![модуль 7](image/32.jpg){#fig-032 width=100%}

![модуль 7](image/33.jpg){#fig-033 width=100%}

Устанавилваем и запускаем htop, настраиваем нужные вам колонки, находим по фильтру процесс и «убиваем его».

![модуль 7](image/34.jpg){#fig-034 width=100%}

Запускаем задачу у низким приоритетом — например, с nice=15. Находим PID процесса, который запускали ранее, и повышаем приоритет до -5. Находим процесс с самым низким приоритетом и пробуем повысить приоритет данного процесса.

![модуль 7](image/35.jpg){#fig-035 width=100%}

Выводим список всех активных сервисов и фильтруем их по фильтру «Network». Определяем, какой веб-сервер установлен, проверяем статус сервиса и перезапускаем его. После перезапуска проверяем журнал на наличие ошибок. 

![модуль 7](image/36.jpg){#fig-036 width=100%}

Находим ненужный сервис. Делаем так, чтобы при перезапуске системы данный процесс не запускался. Перезагружаем устройство, на котором работаете, и проверяем, что выбранный сервис выключен.

![модуль 7](image/37.jpg){#fig-037 width=100%}

Создаем простой Python-скрипт и даем данному файлу права на запуск. 

![модуль 7](image/38.jpg){#fig-038 width=100%}

Создаем unit-файл — активируем и проверяем статус вашего юнита.

![модуль 7](image/39.jpg){#fig-039 width=100%}

Принудительно завершаем процесс, который был запущен в предыдущем задании, и проверяем статус сервиса.

![модуль 7](image/40.jpg){#fig-040 width=100%}

Перезагружаем устройство, на котором работаем, и проверяем, сработал ли автозапуск вашего процесса.


# Выполнение тестовых заданий

![тест](image/1a.jpg){#fig-001 width=100%}

Когда нам нужно получить полное и структурированное описание утилиты, ее опций и примеров использования, мы обращаемся к встроенному справочнику с помощью команды man
Мы используем команду info как альтернативу man для просмотра более подробной документации.
Мы знаем, что после установки пакета его дополнительная документация, лицензии и примеры конфигураций обычно размещаются в каталоге /usr/share/doc/имя_пакета.

![тест](image/2a.jpg){#fig-002 width=100%}

Мы используем конструкцию cat > файл.txt для перенаправления стандартного ввода в новый файл.
Мы применяем оператор >>, когда нужно добавить данные в конец существующего файла, не стирая его предыдущее содержимое. Оператор > всегда создает файл заново или полностью перезаписывает существующий.
Для просмотра больших файлов мы предпочитаем использовать less, так как он позволяет нам листать содержимое страницами, искать по тексту и свободно перемещаться по файлу, в то время как cat вываливает всё содержимое сразу, что неудобно для навигации.

![тест](image/3a.jpg){#fig-003 width=100%}

Для выхода из просмотрщика less мы просто нажимаем клавишу q.
В редакторе Vim, находясь в Normal mode, мы нажимаем клавишу :, чтобы перейти в Command mode.

![тест](image/4a.jpg){#fig-004 width=100%}

Мы обращаемся к каталогу /var/log/, так как он является стандартным местом хранения логов системы и приложений.
Мы используем эту команду, чтобы отфильтровать и просмотреть все записи журнала systemd, относящиеся к службе sshd, начиная с начала текущих суток.
Чтобы увидеть ограниченное количество последних записей, мы используем ключ -n. Команда journalctl -n 20 выведет последние 20 строк журнала.

![тест](image/5a.jpg){#fig-005 width=100%}

Для наблюдения за растущим лог-файлом в реальном времени мы используем команду tail с ключом -f.
Мы знаем, что индивидуальные задания планировщика cron для каждого пользователя хранятся в виде файлов в каталоге /var/spool/cron/

![тест](image/6a.jpg){#fig-006 width=100%}

В записи cron мы используем символ звездочки * для обозначения "каждого" допустимого значения в поле (например, каждую минуту, каждый час).
Чтобы полностью очистить нашу личную таблицу cron, мы выполняем команду crontab -r.

![тест](image/7a.jpg){#fig-007 width=100%}

При создании пользователя мы используем ключ -m, чтобы система автоматически создала для него домашний каталог по умолчанию.
Для полного удаления учетной записи пользователя и его домашнего каталога со всем содержимым мы применяем команду userdel с ключом -r

![тест](image/8a.jpg){#fig-008 width=100%}

Мы используем эту команду, чтобы предоставить пользователю admin права суперпользователя. Ключ -aG гарантирует, что пользователь будет добавлен в группу sudo, а не будет перемещен туда, потеряв все другие групповые членства.
Для редактирования критичных системных файлов /etc/passwd и /etc/shadow мы используем специальную утилиту vipw. Она блокирует файл на время редактирования, предотвращая его одновременное изменение из другого места, что обеспечивает целостность данных.

![тест](image/9a.jpg){#fig-009 width=100%}

Первый символ в выводе ls -l указывает на тип файла. Буква d означает, что это каталог.
Мы используем команду chown в формате "chown владелец:группа файл" для одновременного изменения владельца и группы файла.
Мы расшифровываем числовой формат прав так: 7 (владелец: rwx), 5 (группа: r-x), 4 (остальные: r--). Это соответствует строке rwxr-xr--.

![тест](image/10a.jpg){#fig-010 width=100%}

Все команды, выполненные через sudo, записываются в системный журнал, что позволяет нам отслеживать, кто, когда и что делал с привилегиями root.
После изменения порта SSH демон будет работать на новом порту, но межсетевой экран по умолчанию блокирует все входящие соединения, кроме разрешенных правилами.

![тест](image/11a.jpg){#fig-011 width=100%}

Чтобы разрешить входящие подключения к нестандартному порту SSH, мы добавляем в UFW правило, явно указывающее номер порта и протокол: sudo ufw allow 47022/tcp.
Мы предпочитаем sudo, потому что он позволяет предоставлять привилегированный доступ без разглашения пароля root, обеспечивает детальное логирование действий и дает более гибкое управление правами через файл /etc/sudoers.

![тест](image/12a.jpg){#fig-012 width=100%}

Мы понимаем, что хеширование — это односторонняя криптографическая функция.
Идентификатор алгоритма хеширования, такой как $6$ (SHA-512) или $y$ (yescrypt), указывает системе, какой метод использовался для создания этого хеша.
Мы добавляем "соль" — случайную строку — к паролю перед хешированием. Это гарантирует, что даже одинаковые пароли будут иметь разные хеши.

![тест](image/13a.jpg){#fig-013 width=100%}

Чтобы проверить настройки политики паролей, мы используем команду chage с ключом -l.
Команда usermod -L блокирует учетную запись пользователя, добавляя знак ! в начало его хешированного пароля в /etc/shadow, что делает невозможным вход в систему с этим паролем.

![тест](image/14a.jpg){#fig-014 width=100%}

Для просмотра подробного списка файлов, включая их права доступа, владельца и группу, мы используем команду ls -l.
Комбинация флагов -l и -a в команде ls позволяет нам увидеть права доступа у всех файлов, включая скрытые.
Мы переводим символьные права в числовые: r (read) = 4, w (write) = 2, - (no execute) = 0. Суммируем: 4 + 2 + 0 = 6.

![тест](image/15a.jpg){#fig-015 width=100%}

Для изменения прав доступа мы используем команду chmod.
В символьном режиме команды chmod мы используем операторы: + для добавления прав, - для отзыва прав и = для установки прав в точное значение.
Чтобы рекурсивно применить изменения прав ко всем файлам и подкаталогам внутри директории, мы используем ключ -R.

![тест](image/16a.jpg){#fig-016 width=100%}

Мы устанавливаем Sticky Bit на общедоступные каталоги вроде /tmp, чтобы пользователи могли удалять только свои собственные файлы, даже если у них есть право на запись в каталог.
SUID — это специальное право, которое заставляет исполняемый файл запускаться с правами его владельца, а не пользователя, который его запустил.
Такого параметра не существует.

![тест](image/17a.jpg){#fig-017 width=100%}

Для получения подробного списка всех процессов в системе с информацией о пользователе, PID, использовании CPU и памяти мы используем команду ps aux.
Когда процесс не реагирует на другие сигналы, мы используем команду kill -9, которая отправляет сигнал SIGKILL.
Мы приостанавливаем процесс, работающий в терминале, нажатием Ctrl+Z. Затем, чтобы возобновить его выполнение в фоновом режиме, мы вводим команду bg %1.

![тест](image/18a.jpg){#fig-018 width=100%}

Значение nice определяет приоритет планировщика. Чем оно ниже, тем выше приоритет процесса. Таким образом, значение -20 является наивысшим приоритетом, а 19 — самым низким.
Для изменения приоритета уже работающего процесса мы используем команду renice.
В unit-файле systemd мы используем директиву Nice=, чтобы установить значение nice для всех процессов этого сервиса при их запуске.

![тест](image/19a.jpg){#fig-019 width=100%}

Для проверки состояния, активности и последних логов системного сервиса мы используем команду systemctl status имя_сервиса.
В таймере systemd мы используем директиву OnCalendar= с параметром daily, чтобы настроить ежедневный запуск в полночь.
Чтобы сервис автоматически запускался при загрузке системы, мы "включаем" его с помощью команды systemctl enable. Это создает необходимые символические ссылки.

![тест](image/20a.jpg){#fig-020 width=100%}

Мы используем директиву Restart=always в unit-файле systemd, когда нам нужно, чтобы сервис автоматически перезапускался независимо от того, как он завершился — штатно, с ошибкой или был принудительно остановлен. Это обеспечивает максимальную отказоустойчивость службы.
Для мониторинга журнала конкретного сервиса в реальном времени мы используем команду journalctl -u servicename -f.
Перед тем как запускать новый сервис, мы всегда проверяем его unit-файл на наличие синтаксических ошибок с помощью команды systemd-analyze verify.

# Оценки тестов

![тест 1](image/test1.jpg){#fig-001 width=100%}

![тест 2](image/test2.jpg){#fig-002 width=100%}

![тест 3](image/test3.jpg){#fig-003 width=100%}

![тест 4](image/test4.jpg){#fig-004 width=100%}

![тест 5](image/test5.jpg){#fig-005 width=100%}

![тест 6](image/test6.jpg){#fig-006 width=100%}

![тест 7](image/test7.jpg){#fig-007 width=100%}

![тест 8](image/test8.jpg){#fig-008 width=100%}

![тест 9](image/test9.jpg){#fig-009 width=100%}

![тест 10](image/test10.jpg){#fig-010 width=100%}

![тест 11](image/test11.jpg){#fig-011 width=100%}

![тест 12](image/test12.jpg){#fig-012 width=100%}

![тест 13](image/test13.jpg){#fig-013 width=100%}

![тест 14](image/test14.jpg){#fig-014 width=100%}

![тест 15](image/test15.jpg){#fig-015 width=100%}

# Выводы

Мы выполнили второй раздел внешнего курса "Системный администратор Linux с нуля".

# Список литературы{.unnumbered}

::: {.refs}
1. https://study.selectel.ru/members/courses/course756726784647
:::
